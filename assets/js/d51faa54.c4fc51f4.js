(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[633],{2033:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(2122),o=n(9756),i=(n(7294),n(3905)),r=["components"],s={sidebar_position:1},l="Flaging Component",c={unversionedId:"tutorial-basics/flaging-component",id:"tutorial-basics/flaging-component",isDocsHomePage:!1,title:"Flaging Component",description:"In this section we will learn how to create feature flags for React Component and how to apply a good pattern.",source:"@site/docs/tutorial-basics/flaging-component.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/flaging-component",permalink:"/docs/tutorial-basics/flaging-component",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tutorial-basics/flaging-component.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/Getting Started"}},p=[{value:"Why we should avoid branching statement?",id:"why-we-should-avoid-branching-statement",children:[{value:"Graduation",id:"graduation",children:[]}]}],d={toc:p};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"flaging-component"},"Flaging Component"),(0,i.kt)("p",null,"In this section we will learn how to create feature flags for React Component and how to apply a good pattern."),(0,i.kt)("p",null,"for example our project is structured like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--src/\n----components/\n------PageHeader.tsx\n------BuyButton.tsx\n------Modal.tsx\n----pages/\n------index.tsx\n------blog.tsx\n")),(0,i.kt)("p",null,"and we want to create feature flag for component ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/components/PageHeader.tsx")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/PageHeader.tsx"',title:'"src/components/PageHeader.tsx"'},"import React from 'react';\nimport { Stack, Heading, Text } from '@chakra/react';\n\nconst PageHeader = () => {\n  return (\n    <Stack>\n      <Heading>Welcome to our website</Heading>\n      <Text>Description 1</Text>\n    </Stack>\n  );\n};\n\nexport default PageHeader;\n")),(0,i.kt)("p",null,"the new version of ",(0,i.kt)("inlineCode",{parentName:"p"},"PageHeader")," is replacing ",(0,i.kt)("inlineCode",{parentName:"p"},"<Text>")," node with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<Stack>\n  <Text>Description 1</Text>\n  <Text>Description 2</Text>\n</Stack>\n")),(0,i.kt)("p",null,"the simples way to do this is by using ",(0,i.kt)("inlineCode",{parentName:"p"},"branching statement")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createToggleFn } from '@warungpintar/morphling-core';\n\nconst isFlagEnabled = createToggleFn('page-header-v2')(() => false)(() => true);\n\nconst PageHeader = () => {\n  return (\n    <Stack>\n      <Heading>Welcome to our website</Heading>\n      {isFlagEnabled() ? (\n        <Stack>\n          <Text>Description 1</Text>\n          <Text>Description 2</Text>\n        </Stack>\n      ) : (\n        <Text>Description 1</Text>\n      )}\n    </Stack>\n  );\n};\n")),(0,i.kt)("p",null,"but that's not the recomended way to do it, we will explain it later."),(0,i.kt)("p",null,"Instead, we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"HOC")," and separate the logic per file. so in this case we will create new component file in ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/experiments/components/PageHeader.tsx")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/src/experiments/components/PageHeader.tsx"',title:'"/src/experiments/components/PageHeader.tsx"'},"import React from 'react';\nimport { Stack, Heading, Text } from '@chakra/react';\n\nconst PageHeader = () => {\n  return (\n    <Stack>\n      <Heading>Welcome to our website</Heading>\n      <Stack>\n        <Text>Description 1</Text>\n        <Text>Description 2</Text>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport default PageHeader;\n")),(0,i.kt)("p",null,"then we modify the original component by wrapping it with ",(0,i.kt)("inlineCode",{parentName:"p"},"HOC")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/PageHeader.tsx"',title:'"src/components/PageHeader.tsx"'},"import { withFeatureToggle } from '@warungpintar/morphling-react';\nimport PageHeaderV2 from '../experiments/components/PageHeader';\n\n// the rest of the code\n\nexport default withFeatureToggle('page-header-v2')(PageHeader)(PageHeaderV2);\n")),(0,i.kt)("h2",{id:"why-we-should-avoid-branching-statement"},"Why we should avoid branching statement?"),(0,i.kt)("p",null,"Feature Flags / AB Testing is technique for testing out different version of code that can be switched at runtime, or another use case is testing out new feature in production. for example we have music player app and we want to test our new sound animation component."),(0,i.kt)("p",null,"The sound animation feature is critical because 90% of users are happy about it, so if we want to replace / upgrade the current animation we should really careful about it! because the new component shouldn't break at runtime or atleast if the new component breaks we can switch back to the old component instantly without any problem."),(0,i.kt)("p",null,"Common way to achieve this objective is make sure the old component is untouch, so we sure that it's functionality doesn't change. and we can't achieve this by using ",(0,i.kt)("inlineCode",{parentName:"p"},"branching statement")," because we need to touch the logic to create the ",(0,i.kt)("inlineCode",{parentName:"p"},"branch statement")),(0,i.kt)("p",null,"That's why it's really important to use ",(0,i.kt)("inlineCode",{parentName:"p"},"HOC")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"React Component"),", and isolate the component per file!"),(0,i.kt)("h3",{id:"graduation"},"Graduation"),(0,i.kt)("p",null,"Graduation is term for releasing flaged component and cleaning up the old component, this process is important to do to keep our codebase clean and the bundle size small. the ",(0,i.kt)("inlineCode",{parentName:"p"},"common")," problem using ",(0,i.kt)("inlineCode",{parentName:"p"},"branching statement")," is hard and high risk."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"we need to touch the logic to remove the branching statement"),(0,i.kt)("li",{parentName:"ol"},"hard to tell how many flagged component are still in our codebase"),(0,i.kt)("li",{parentName:"ol"},"sometimes if we fucked up, the error not catched at build process.")),(0,i.kt)("p",null,"The benefit of using hoc and isolate into difference files is:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"we dont have to touch the logic, just need to change the export statement"),(0,i.kt)("li",{parentName:"ol"},"it's easy to tell how many experiments are in our codebase, just count how many files in ",(0,i.kt)("inlineCode",{parentName:"li"},"experiments")," folder"),(0,i.kt)("li",{parentName:"ol"},"delete some files in experiments folder -> build -> the error will be catched")))}u.isMDXComponent=!0}}]);